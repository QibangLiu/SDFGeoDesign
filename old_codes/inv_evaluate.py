# %%
from shapely.geometry import Polygon, Point
from skimage import measure
import models
from torch.utils.data import TensorDataset, DataLoader
import torch_trainer
import torch
import numpy as np
import matplotlib.pyplot as plt
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# %%

_, _, sdf_test, stress_test, sdf_inv_scaler, stress_inv_scaler, strain = models.LoadData(
    seed=52)
test_dataset = TensorDataset(sdf_test, stress_test)

fwd_model = models.LoadForwardModel()


inv_Unet, gaussian_diffusion = models.LoadDiffusionInverseModel()
# %%
seed = 62  # 52,62, 72
torch.manual_seed(seed)
# If using CUDA
if device == "cuda":
    torch.cuda.manual_seed(seed)
    torch.cuda.manual_seed_all(seed)  # For multi-GPU setups
# Set the seed for NumPy
np.random.seed(seed)

id = np.random.randint(0, len(test_dataset))
num_sol = 1000
img_shape = sdf_test.shape[1:]
Ytarget = test_dataset[id][1].unsqueeze(0)
Ytarget = Ytarget.to(device)
labels = Ytarget.repeat(num_sol, 1)
Xpred = gaussian_diffusion.sample(
    inv_Unet, img_shape, labels, w=2, clip_denoised=False, conditioning=True
)

Xpred = torch.tensor(Xpred).to(device)
# %%

with torch.no_grad():
    Ypred = fwd_model(Xpred)
Ypred_inv = stress_inv_scaler(Ypred.cpu().detach().numpy())
Ytarg_inv = stress_inv_scaler(labels.cpu().detach().numpy())
Xpred_inv = sdf_inv_scaler(Xpred.cpu().detach().numpy())
L2error = np.linalg.norm(Ypred_inv - Ytarg_inv, axis=1) / \
    np.linalg.norm(Ytarg_inv, axis=1)

# %%
sorted_idx = np.argsort(L2error)
fig = plt.figure(figsize=(4.8, 3.6))
ax = plt.subplot(1, 1, 1)
_ = ax.hist(L2error[sorted_idx], bins=20, color="skyblue", edgecolor="black")
ax.set_xlabel("L2 relative error")
ax.set_ylabel("Frequency")


# %%
good_ids = np.where(L2error < 0.1)[0]
best_id = sorted_idx[0]
np.random.seed(2)
evl_ids = np.sort(np.random.choice(good_ids, 6, replace=False))
evl_ids = evl_ids[evl_ids != best_id]
evl_ids = np.concatenate(([best_id], evl_ids[:5]))
evl_ids = evl_ids[np.argsort(L2error[evl_ids])]
legends = []
for i in range(0, len(evl_ids)):
    legends.append(f"{100*L2error[evl_ids[i]]:.1f}%")


for i, idx in enumerate(evl_ids):
    print(f"ID: {idx}, L2 error: {L2error[idx]}"),

fig = plt.figure(figsize=(4.8, 3.6))
ax = plt.subplot(1, 1, 1)
ax.plot(strain[::2], Ytarg_inv[0, ::2], '-ro', label="target", markersize=4)
for i, v in enumerate(evl_ids):
    ax.plot(strain, Ypred_inv[v], '--', label=legends[i])
ax.set_ylim([0, 1.5*np.max(Ytarg_inv[0])])
ax.legend()
ax.set_xlabel(r"$\varepsilon~[\%]$")
ax.set_ylabel(r"$\sigma~[MPa]$")

num_fig = len(evl_ids)
nr, nc = 2, 3
fig = plt.figure(figsize=(6 * nr, 2.4*nc))
for i, v in enumerate(evl_ids):
    contours = measure.find_contours(
        Xpred_inv[v, 0], 0, positive_orientation="high")
    ax = plt.subplot(nr, nc, i + 1)
    l_style = ["r-", "b--"]
    holes = []
    for j, contour in enumerate(contours):
        contour = (contour - 10) / 100
        x, y = contour[:, 1], contour[:, 0]
        if j == 0:
            ax.fill(
                x,
                y,
                alpha=1.0,
                edgecolor="black",
                facecolor="cyan",
                label="Outer Boundary",
            )
        else:
            ax.fill(x, y, alpha=1.0, edgecolor="black",
                    facecolor="white", label="Hole")
        # ax.grid(True)
        ax.axis("off")
        ax.axis("equal")  # Keep aspect ratio square
        ax.set_title(f"{legends[i]}")
plt.tight_layout()


# %%
x_pred = Xpred[evl_ids]
sdfs = sdf_inv_scaler(x_pred.cpu().detach().numpy())
for sdf in sdfs[:1]:
    contours = measure.find_contours(
        sdf[0], 0, positive_orientation="high")
    polygons = []
    for contour in contours:
        contour = (contour - 10) / 100
        xy = contour[:, ::-1]
        polygons.append(Polygon(xy))
        # polygon_b = Polygon(contour_b)


def Decoder(x_pred, sdf_inv_scaler):
    """
    args:
    x_pred: torch.tensor, generated by diffusion model
            shape (num_sol,1,120,120)
    """
    sdfs = sdf_inv_scaler(x_pred.cpu().detach().numpy())
    for sdf in sdfs:
        contours = measure.find_contours(
            sdf[0], 0, positive_orientation="high")

# %%
